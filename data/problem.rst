Vấn đề: Chúng ta làm gì với dữ liệu?
------------------------------------

Từ góc nhìn của mạng, các chương trình ứng dụng gửi thông điệp cho nhau. Mỗi thông điệp này chỉ là một chuỗi byte không được diễn giải. Tuy nhiên, từ góc nhìn của ứng dụng, các thông điệp này chứa nhiều loại *dữ liệu* khác nhau—mảng số nguyên, khung hình video, dòng văn bản, ảnh số, v.v. Nói cách khác, các byte này có ý nghĩa. Bây giờ chúng ta sẽ xem xét vấn đề làm thế nào để mã hóa tốt nhất các loại dữ liệu khác nhau mà các chương trình ứng dụng muốn trao đổi thành các chuỗi byte. Ở nhiều khía cạnh, điều này tương tự như vấn đề mã hóa chuỗi byte thành tín hiệu điện từ mà chúng ta đã thấy ở chương trước.

Nhớ lại cuộc thảo luận về mã hóa, về cơ bản có hai mối quan tâm. Đầu tiên là bên nhận phải có thể trích xuất cùng một thông điệp từ tín hiệu như bên gửi đã gửi; đây là vấn đề đóng khung (framing). Thứ hai là làm cho việc mã hóa hiệu quả nhất có thể. Cả hai mối quan tâm này cũng xuất hiện khi mã hóa dữ liệu ứng dụng thành thông điệp mạng.

Để bên nhận có thể trích xuất thông điệp do bên gửi gửi, hai bên cần đồng ý về một định dạng thông điệp, thường gọi là *định dạng trình bày* (presentation format). Nếu bên gửi muốn gửi cho bên nhận một mảng số nguyên, chẳng hạn, thì hai bên phải đồng ý mỗi số nguyên trông như thế nào (dài bao nhiêu bit, thứ tự sắp xếp các byte, và bit quan trọng nhất nằm trước hay sau, v.v.) và có bao nhiêu phần tử trong mảng. Phần đầu tiên sẽ mô tả các kiểu mã hóa dữ liệu máy tính truyền thống, như số nguyên, số thực dấu phẩy động, chuỗi ký tự, mảng và cấu trúc. Các định dạng chuẩn cũng tồn tại cho dữ liệu đa phương tiện: Ví dụ, video thường được truyền theo một trong các định dạng do Nhóm Chuyên gia Hình ảnh Động (MPEG) tạo ra, và ảnh tĩnh thường được truyền theo định dạng của Nhóm Chuyên gia Ảnh (JPEG). Các vấn đề cụ thể phát sinh khi mã hóa dữ liệu đa phương tiện sẽ được bàn trong phần tiếp theo.

Các kiểu dữ liệu đa phương tiện buộc chúng ta phải nghĩ đến cả trình bày và *nén*. Các định dạng nổi tiếng cho truyền và lưu trữ âm thanh, video đều xử lý cả hai vấn đề này: đảm bảo những gì được ghi lại, chụp ảnh hoặc nghe ở bên gửi có thể được diễn giải đúng ở bên nhận, và làm điều đó theo cách không làm mạng bị quá tải bởi lượng dữ liệu đa phương tiện khổng lồ.

Nén và, nói rộng hơn, hiệu quả của mã hóa có một lịch sử phong phú, bắt nguồn từ công trình tiên phong của Shannon về lý thuyết thông tin vào những năm 1940. Thực tế, có hai lực đối lập cùng tác động ở đây. Ở một hướng, bạn muốn càng nhiều dư thừa trong dữ liệu càng tốt để bên nhận có thể trích xuất đúng dữ liệu ngay cả khi có lỗi xuất hiện trong thông điệp. Các mã phát hiện và sửa lỗi mà chúng ta đã thấy ở chương trước thêm thông tin dư thừa vào thông điệp chính xác vì mục đích này. Ở hướng ngược lại, chúng ta muốn loại bỏ càng nhiều dư thừa khỏi dữ liệu càng tốt để có thể mã hóa nó bằng càng ít bit càng tốt. Hóa ra dữ liệu đa phương tiện mang lại rất nhiều cơ hội cho việc nén nhờ cách giác quan và não bộ chúng ta xử lý tín hiệu hình ảnh và âm thanh. Chúng ta không nghe rõ các tần số cao như các tần số thấp, và chúng ta không chú ý đến chi tiết nhỏ bằng tổng thể của một hình ảnh, đặc biệt nếu hình ảnh đó đang chuyển động.

Nén dữ liệu quan trọng với các nhà thiết kế mạng vì nhiều lý do, không chỉ vì chúng ta hiếm khi có dư thừa băng thông ở mọi nơi trong mạng. Ví dụ, cách chúng ta thiết kế thuật toán nén ảnh hưởng đến độ nhạy của chúng ta với dữ liệu bị mất hoặc bị trễ và do đó có thể ảnh hưởng đến thiết kế các cơ chế phân bổ tài nguyên và các giao thức đầu-cuối. Ngược lại, nếu mạng bên dưới không thể đảm bảo một lượng băng thông cố định trong suốt thời gian hội nghị truyền hình, chúng ta có thể chọn thiết kế các thuật toán nén có khả năng thích nghi với điều kiện mạng thay đổi.

Cuối cùng, một khía cạnh quan trọng của cả định dạng trình bày và nén dữ liệu là chúng yêu cầu các máy chủ gửi và nhận phải xử lý từng byte dữ liệu trong thông điệp. Chính vì lý do này mà định dạng trình bày và nén đôi khi được gọi là các chức năng *xử lý dữ liệu* (data manipulation). Điều này trái ngược với hầu hết các giao thức mà chúng ta đã thấy cho đến thời điểm này, vốn xử lý một thông điệp mà không cần xem nội dung của nó. Do cần phải đọc, tính toán và ghi từng byte dữ liệu trong một thông điệp, các thao tác xử lý dữ liệu ảnh hưởng đến thông lượng đầu-cuối trên mạng. Trong một số trường hợp, các thao tác này có thể là yếu tố giới hạn.
